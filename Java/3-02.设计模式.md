

## 设计模式六大原则

- a.单一职责原则：就一个类来说，应该只有一个引起它变化的原因
一个类做一件事情，避免职责过多。比如这种情况是不太好的，在一个Activity中既有bean文件，又有http请求，还有adapter等等，这就导致我们需要修改任何一个东西的时候都会导致Activity的改变，这样一来就有多个引起它变化的原因，不符合单一职责原则
- b.开放封闭原则：类，模块，函数应该是可以扩展的，但是不可以修改
对于扩展是开放的，对于修改是封闭的。尽量做到面对需求的改变时，我们的代码能保持相对稳定，通过扩展的方式应对变化，而不是修改原有代码实现
- c.里氏替换原则：所有引用基类的地方，必须可以透明的时候其子类的对象
里氏替换原则是实现开放封闭原则的重要方式之一，我们知道，使用基类的地方都可以使用子类去实现，因为子类拥有基类的所有方法，所以在程序设计中尽量使用基类类型对对象进行定义，在运行时确定子类类型。
- d.依赖倒置原则：高层模块不应该依赖于底层模块，两者都应该依赖于抽象，抽象不应该依赖于细节，细节应该依赖于抽象
依赖倒置原则针对的是模块之间的依赖关系，高层模块指调用端，底层模块指具体的实现类，抽象指接口或抽象类，细节就是实现类。该原则的具体表现就是模块间的依赖通过抽象发生，直线类之间不发生直接依赖关系，依赖通过接口或抽象类产生，降低耦合，比如MVP模式下，View层和P层通过接口产生依赖关系
- e.迪米特原则（最少知识原则）：一个软件实体应该尽可能少的与其他实体发生相互作用
迪米特原则要求我们在设计系统时，尽量减少对象之间的交互
f.接口隔离原则：一个类对另一个类的依赖应该建立在最小的接口上
接口隔离原则的关键是接口以及这个接口要小，如何小呢，也就是我们要为专门的类创建专门的接口，这个接口只对它有效，不要试图让一个接口包罗万象，要建立最小的依赖关系

## 设计模式的分类
设计模式分为三类
- 创建型设计模式
与对象创建有关包括单例模式，工厂方法模式，抽象工厂模式，建造者模式，原型模式
- 结构型设计模式
结构性设计模式是从程序的结构上解决模块之间的耦合问题，包括适配器模式，代理模式，装饰模式，外观模式，桥接模式，组合模式和享元模式
- 行为型设计模式
主要处理类或对象如何交互及如何分配职责，包括策略模式，模板方法模式，观察者模式，迭代器模式，责任链模式，命令模式，备忘录模式，状态模式，访问者模式，中介模式，解析器模式



## 设计模式详解

#### 一、单例模式

单例模式是一种对象创建模式，它用于产生一个对象的具体实例，它可以确保系统中一个类只产生一个实例。
 **好处：**

- 对于频繁使用的对象，可以省略从创建对象的花费时间，这对于那些重量级对象而言，是非常可观的一笔系统开销。
- 由于new操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻GC压力，缩短GC停顿时间。

单例包含：饿汉、懒汉、懒汉线程安全、DCL、静态内部类、枚举六种。

**①** **饿汉**
 不足之处：无法对instance实例化做延时加载
 优化： 懒汉

**②** **懒汉**
 不足之处：在多线程并发下这样的实现是无法保证实例是唯一的
 优化：懒汉线程安全

**③** **懒汉线程安全**
 方式1： 方法中声明synchronized关键字
 方式2：同步代码实现，例如：
 synchronized(lazySafeSingleton.class) {… …}
 不足之处：性能效率问题（使用synchronized导致性能缺陷）
 优化： DCL

**④ DCL(**双重检验锁机制**)**
 不足之处：jvm的即使编译器中存在指令重排序的优化
 优化： 静态内部类或枚举
 可以解决办法： pirvate static ***volatile\*** DCLSingleton mInstance = null;

**⑤** **静态内部类**
 优点： jvm本身机制保证了线程安全，没有性能缺陷
 原因： static final

```
public class staticInnerSingleton {
               private staticInnerSingleton() {}
               public static staticInnerSingleton getInstance() {
                              return singletonHolder.sInstance;
               }
               private static class SingletonHolder {  // 定义为静态私有内部类
                              private static final staticInnerSingleton sInstatic = new staticInnerSingleton();
               }
}
```

**⑥** **枚举**
 优点： 写法简单，线程安全

```
public enum singletonEnum {
               // 定义一个枚举的元素，它就是singleton的一个实例
               INSTANCE;
               // 定义这个枚举的修改操作
               public void doSomething() {
                              // do something... 
                              system.out.println("一些操作...");
               }
}
 
public static void main(string[] args) {
               singletonEnum s = singletonEnum.INSTANCE;
               s.doSomething();
}
```

静态内部类/枚举：延迟加载/线程安全/性能优势。

**单例模式在**Android**中的实际运用：**
 Application**





#### 二、builder（建造者模式/生成器模式）

**概念：** 建造者模式是较为复杂的创建型模型，它将客服端与包含多个组成部分（或部件）的复杂对象的创建过程分离。
 **使用场景：** 当构造一个对象需要很多参数的时候，并且参数的个数或类型不固定的时候。
 **builder模式的优点：**
 ① 松散耦合： 建造者/生成器模式可以用同一个构建算法构建出表现完全不同的产品，实现构建和产品表现上的分离。
 ② 可以很容易的改变产品的内部表示。
 ③ 更好的复用性，建造者模式很好的实现构建算法和具体产品实现的分离。
 **builder模式的缺点：**
 ① 会产生多余的builder对象，消耗内存。
 ② 对象的构建过程暴露。

**builder模式在Android中的实际运用：****
 ①AlertDialog(****主要实现是****AlertController****类****)
 ②Glide/okhttp**

#### 三、Adapter(适配器模式)

**适配器模式定义：** 将一个接口转换成客户希望的另外一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器（wrapper）。
 **类适配器定义：** 类的适配器模式把适配的类的API转换为目标类的API
 **对象适配器定义：** 与类的适配器一样，对象的适配器模式把被适配的类的API转换成为目标类的API，与类的适配器模式不同的是，对象的适配器模式不是使用继承关系连接到Adaptee类，而是使用委派关系连接到Adaptee类。
 **类适配器和对象适配器的区别：**
 类适配器中的Adapter是继承Adapter类并实现Target接口。
 而对象适配器中的Adapter只是实现Target接口，在Adapter中引用Adaptee中的方法，即使用委托/委派关系连接到Adaptee类。

#### 四、装饰模式（Decorator Pattern）

**装饰模式定义：** 动态的给一个对象增加一些额外的职责就增加对象功能来说，装饰模式比生成子类实现更为灵活，装饰模式是一种对象结构型模式。
 **使用场景：**
 ① 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。
 ② 当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时可以使用装饰模式。
 **装饰模式的优点：**
 ① 对于扩展一个对象的功能，装饰模式比继承更加灵活，不会导致类的个数急剧增加（降低耦合度）。
 ② 可以通过一种动态的方式来扩展一个对象的功能。
 ③ 可以对一个对象进行多次装饰，通过使用不同的具体装饰类以及这些装饰类的排列组合。
 ④ 具体装饰类可以独立变化。

**装饰模式在Android中的实际运用：**
 Context****类簇在装饰模式的应用**

#### 五、外观模式

**概念：** 外观设计的主要目的载应让外部减少与子系统内部多个模块的交互，从而让外部能够更简单得使用子系统，它负责把客户端的请求转发给子系统内部的各个模块进行处理。
 **使用场景：**
 ① 当你要为一个复杂子系统提供一个简单接口时。
 ② 客户程序与抽象类的实现部分之间存在着很大的依赖性。
 ③ 当你需要构建一个层次结构的子系统时。
 **外观模式的优点：**
 ① 由于Facade类封装了各个模块交互的过程，如果今后内部模块调用关系发生了变化，只需要修改Facade实现就可以了。
 ② Facade实现可以被多个客服端调用的。

**外观模式在Android中的实际运用：**

 contextImpl——>android中的外观类**

#### 六、组合模式

**概念：** 将对象以树形结构组织起来，以达成“部分–整体”的层级结构，使得客服端对单个对象和组合对象的使用具有一致性（不要区别整体和个体的使用）。
 **树的结构****–>****组合设计模式**
 **使用场景：**
 ① 需要表示一个对象整体或部分层次。
 ② 让客户能够忽略不同对象层次的变化。
 **组合模式的优点：**
 ① 高层模块调用简单
 ② 节点自由增加

**组合模式在Android中的实际运用：**

 Android中的View的结构是树形结构**

#### 七、策略模式

**概念：** 定义一系列的算法，把他们一个个封装起来，并且使他们可互相替换，本模式使得算法可独立于使用它的客户而变化。
 **使用场景：** 一个类定义了多种行为，并且这些行为在这个类的方法中以多个条件语句的形式出现，那么可以使用策略模式避免在类中使用大量的条件语句。
 **策略模式的优点：**
 ① 上下文（context）和具体策略（concreteStrategy）是松耦合关系。
 ② 策略模式满足"开–闭"原则。

**策略模式在Android中的实际运用：**
 Volley****中对****HttpStack****的设计用到的就是策略模式**

#### 八、模板方法模式

**概念：** 模板方法是通过定义一个算法骨架，而将算法中的步骤延迟到子类，这样子类就可以复写这些步骤的实现来实现特定的算法。
 **使用场景：**
 ① 多个子类公有的方法，并且逻辑基本相同时。
 ② 重要、复杂的算法，可以把核心算法设计为模板方法。
 ③ 重构时，模板方法模式是一个经常使用的模式。
 **抽象模板****/****具体模板：**
 定义的数量和类型/模板方法的数量

**模板方法模式在**Android中的实际运用：
 ① Activity****（****onCreate()****、** **onStart()****、****onResume()…****）****
 ② Fragment
 ③AsyncTask**

有关AsyncTask相关知识点：
 ① Future接口：用来获取异步计算结果的，说白了就是对具体的Runnable或Callable对象任务执行的结果进行获取（get()）、取消（cancel()），判断是否完成任务。
 ② FutureTask: FutureTask除了实现Future接口外还实现了Runnable接口，因此FutureTask也可以直接提交给Executor执行。

#### 九、观察者模式

**概念：** 定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖关系皆得到通知并被通知自动更新。
 **使用场景：**
 ① 一个抽象模型有两个方面，其中一个方面依赖另外一个方面。
 ② 一个对象的改变将导致一个或多个其他对象也发生改变。
 ③ 需要在系统中创建一个触发链。

**观察者模式在Android中的实际运用：
 **①**回调模式**，比如Button的onclick就是用的回调。
 回调模式：实现了抽象类/接口的实例实现了父类提供的抽象方法后，将该方法交还给父类来处理。
 ② ListView中的notifyDataChanged
 ③ Rxjava

#### 十、责任链模式

**概念：** 是一个请求有多个对象来处理，这些对象是一条链，但具体由哪个对象来处理，根据条件判断来确定，如果不能处理会传递给该链中的下一个对象，直到有对象处理它位置。
 **使用场景：**
 ① 有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定。
 ② 在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。
 ③ 可多头指定一组对象处理请求，客服端可以动态创建职责链来处理请求。

**责任链模式在Java/Android中的实际运用：**

 ① try- catch语句
 ② Ordered Broadcast
 ③ ViewGroup / View**事件传递**



#### 开发中用到的设计模式用在什么场合：

 ① singleton：单例 --> 用来减少垃圾对象和缓存用
 ② factory：工厂模式 -->用来解耦
 ③ facade(外观模式)和decorator(装饰模式) -->封装接口
 ④ command(命令模式) -->传递
 ⑤ Iterator(迭代器) --> 用来遍历对象
 ⑥ observer(观察者模式) --> 用来监听状态变化
 ⑦ template(模板模式) -->用来处理相同的操作步骤
 ⑧ strategy(策略模式) --> 策略选择
 ⑨ proxy(代理模式) -->用来附加功能，属性或隐藏
 ⑩ bridge(桥接模式) -->用来解耦工厂和产品搭配之类的选择

责任链模式意图：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。
 责任链模式 -->只关心相邻节点传递事件给相邻节点，不关心之后的流程，例如事件分发机制。
 策略模式 -->了解整个策略知道传给谁处理了。

 