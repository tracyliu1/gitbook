### 线程间协作


#### Thread类  

#####  1.run()和start()区别？

- run() 不会启动新线程 相当于是使用t这个类中的run方法而已.
- start() 启动新创建的线程，jvm内部调用了run()



##### 2.join

合并线程，t.join()直到t执行完毕再执行其他线程（Waits for this thread to die.）

[Java线程Thread.join方法解析](https://www.jianshu.com/p/367fa66bf3f2)


有三个线程T1，T2，T3，怎么确保它们按顺序执行？
> 在多线程中有多种方法让线程按特定顺序执行，你可以用线程类的join()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。为了确保三个线程的顺序你应该先启动最后一个(T3调用T2，T2调用T1)，这样T1就会先完成而T3最后完成。


##### 3.yield

将线程的Running状态转变为Runnable状态


```
/**
*  本地方法，作用是暂停当前线程，使得当前线程放弃对处理器的占用
*  但是此方法不可靠，调度器可能会忽略该方法，暂停后仍然有可能继续运行
*  使用的时候要仔细分析和测试，确保能达到预期的效果。
*  很少有场景要用到该方法，主要使用的地方是调试和测试。　　
*/
public static native void yield();  

```



##### 4.thread.sleep() 和 Object wait()；



- Thread.sleep不会导致锁行为的改变，如果当前线程是拥有锁的，那么Thread.sleep不会让线程释放锁。如果能够帮助你记忆的话，==可以简单认为和锁相关的方法都定义在Object类中，因此调用Thread.sleep是不会影响锁的相关行为。==
- Thread.sleep和Object.wait都会暂停当前的线程，对于CPU资源来说，不管是哪种方式暂停的线程，都表示它暂时不再需要CPU的执行时间。OS会将执行时间分配给其它线程。区别是，调用wait后，需要别的线程执行notify/notifyAll才能够重新获得CPU执行时间。



##### Sleep() ：
sleep方法的作用是让当前线程暂停指定的时间


##### Wait()： 
> wait()方法的作用是将当前运行的线程挂起（即让其进入阻塞状态）。

wait方法的使用必须在同步的范围内，否则就会抛出IllegalMonitorStateException异常，wait方法的作用就是阻塞当前线程等待notify/notifyAll方法的唤醒，或等待超时后自动唤醒。


##### notify() 、notifyAll()

- notify()唤醒monitor对象上的一个线程  
- notifyAll()  唤醒monitor对象上的所有线程

notify()默认的唤醒策略是：先进入wait()的线程先被唤醒。

notifyAll()唤醒所有的等待线程，默认的唤醒策略是：LIFO（后进先出）。


---
[Java 并发编程：线程间的协作(wait/notify/sleep/yield/join)](https://www.cnblogs.com/paddix/p/5381958.html)